"""
Dynamically generates Manim animation code based on topic and script
This ensures every video is unique, interactive, and educational
"""

import json
from pathlib import Path
import re


def analyze_topic_type(topic, wiki_info, script):
    """Analyze topic to determine what kind of animations to create"""
    
    topic_lower = topic.lower()
    script_lower = script.lower()
    wiki_text = wiki_info.get("summary", "").lower() if wiki_info else ""
    
    # Detect topic categories
    animations = []
    
    # Number sequences
    if any(word in topic_lower for word in ["fibonacci", "prime", "sequence", "series"]):
        animations.append("number_sequence")
    
    # Geometry
    if any(word in topic_lower for word in ["triangle", "circle", "square", "polygon", "geometry"]):
        animations.append("geometric_shapes")
    
    # Theorems with proofs
    if any(word in topic_lower for word in ["theorem", "pythagorean", "fermat", "euler"]):
        animations.append("theorem_proof")
    
    # Equations and formulas
    if any(word in script_lower for word in ["equation", "formula", "equals", "="]):
        animations.append("formula_visualization")
    
    # Patterns and fractals
    if any(word in topic_lower for word in ["fractal", "mandelbrot", "pattern", "chaos"]):
        animations.append("fractal_pattern")
    
    # Calculus
    if any(word in topic_lower for word in ["derivative", "integral", "limit", "calculus"]):
        animations.append("calculus_graph")
    
    # Graph theory
    if any(word in topic_lower for word in ["graph", "network", "tree", "vertex"]):
        animations.append("graph_network")
    
    # Probability
    if any(word in topic_lower for word in ["probability", "random", "distribution", "statistics"]):
        animations.append("probability_visual")
    
    # Default: show concept with text and shapes
    if not animations:
        animations.append("concept_explanation")
    
    return animations


def extract_key_points(script):
    """Extract key points from script for visualization"""
    sentences = script.split('. ')
    
    key_points = []
    for i, sentence in enumerate(sentences[:8]):  # Max 8 points
        if sentence.strip():
            # Clean the sentence
            clean = sentence.strip()
            if not clean.endswith('.') and not clean.endswith('!') and not clean.endswith('?'):
                clean += '.'
            
            # If sentence is too long, split it intelligently
            if len(clean) > 100:
                # Try to split at commas or conjunctions
                words = clean.split()
                if len(words) > 10:
                    # Take first 10-12 words for readability
                    clean = ' '.join(words[:12]) + '...'
            
            key_points.append({
                "text": clean,
                "index": i,
                "has_number": bool(re.search(r'\d+', clean)),
                "has_formula": bool(re.search(r'[=+\-*/^]', clean))
            })
    
    return key_points


def generate_manim_code(topic, script, wiki_info, formula, audio_duration=60.0):
    """Generate complete Manim animation code dynamically"""
    
    print(f"🎨 Generating custom Manim code for: {topic}")
    print(f"🎵 Syncing to audio duration: {audio_duration:.1f}s")
    
    # Analyze what animations to include
    animation_types = analyze_topic_type(topic, wiki_info, script)
    key_points = extract_key_points(script)
    
    print(f"  Animation types: {', '.join(animation_types)}")
    print(f"  Key points: {len(key_points)}")
    
    # Calculate timing based on audio duration
    intro_duration = 4.0
    outro_duration = 6.0
    content_duration = audio_duration - intro_duration - outro_duration
    
    # Distribute time across key points
    num_key_points = min(len(key_points), 5)
    if num_key_points > 0:
        time_per_point = content_duration / (num_key_points + 2)  # +2 for animations
    else:
        time_per_point = 3.0
    
    # Escape special characters in topic for Python strings
    safe_topic = topic.encode('ascii', 'ignore').decode('ascii')  # Remove non-ASCII
    if not safe_topic:
        safe_topic = topic  # Keep original if all chars were non-ASCII
    
    # Build the Manim script
    code = f'''"""
Dynamically Generated Manim Animation
Topic: {safe_topic}
Generated by AI-powered video creation system
"""

from manim import *
import numpy as np

class DynamicScene(Scene):
    """Custom animation for: {safe_topic}"""
    
    def construct(self):
        # Add audio
        audio_file = "output/audio.mp3"
        from pathlib import Path
        if Path(audio_file).exists():
            self.add_sound(audio_file)
        
        # === INTRO (0-4 seconds) ===
        self.show_intro()
        
        # === MAIN CONTENT (4-50 seconds) ===
'''
    
    # Add appropriate animations based on analysis
    if "number_sequence" in animation_types:
        code += "        self.animate_number_sequence()\n"
    
    if "geometric_shapes" in animation_types:
        code += "        self.animate_geometry()\n"
    
    if "theorem_proof" in animation_types:
        code += "        self.animate_theorem()\n"
    
    if "formula_visualization" in animation_types:
        code += "        self.animate_formula()\n"
    
    if "fractal_pattern" in animation_types:
        code += "        self.animate_fractal()\n"
    
    if "calculus_graph" in animation_types:
        code += "        self.animate_calculus()\n"
    
    if "graph_network" in animation_types:
        code += "        self.animate_graph_network()\n"
    
    if "probability_visual" in animation_types:
        code += "        self.animate_probability()\n"
    
    # Always show key points
    code += "        self.show_key_points()\n"
    
    code += '''
        # === OUTRO (50-60 seconds) ===
        self.show_outro()
    
    def show_intro(self):
        """Show title and topic introduction with dynamic animation"""
        # Animated background elements
        circles = VGroup(*[
            Circle(radius=0.3 + i*0.2, color=BLUE, stroke_width=2, stroke_opacity=0.3)
            for i in range(5)
        ])
        
        self.play(
            LaggedStart(*[Create(c) for c in circles], lag_ratio=0.2),
            run_time=1
        )
        self.play(FadeOut(circles), run_time=0.5)
        
        # Main title with emphasis
        title = Text(
            "''' + safe_topic.replace('"', '\\"').replace("'", "\\'") + '''",
            font_size=56,
            weight=BOLD,
            color=YELLOW,
            gradient=(YELLOW, GOLD)
        )
        
        # Ensure title fits with proper margin
        max_width = config.frame_width - 1.5
        if title.width > max_width:
            title.scale(max_width / title.width)
        
        # Ensure title height is reasonable
        max_height = 2.5
        if title.height > max_height:
            title.scale(max_height / title.height)
        
        # Subtitle with icon
        subtitle = Text("📐 Mathematics", font_size=40, color=BLUE_B)
        subtitle.next_to(title, DOWN, buff=0.6)
        
        # Ensure subtitle fits
        if subtitle.width > max_width:
            subtitle.scale(max_width / subtitle.width)
        
        # Animated entrance
        self.play(
            Write(title, run_time=1.3),
            rate_func=smooth
        )
        self.play(
            FadeIn(subtitle, shift=UP, scale=1.2),
            run_time=0.7
        )
        
        # Pulse effect
        self.play(
            title.animate.scale(1.05),
            run_time=0.3
        )
        self.play(
            title.animate.scale(1/1.05),
            run_time=0.3
        )
        
        self.wait(0.4)
        
        # Exit with style
        self.play(
            FadeOut(title, shift=UP, scale=0.8),
            FadeOut(subtitle, shift=UP, scale=0.8),
            run_time=0.6
        )
    
    def animate_number_sequence(self):
        """Animate number sequences with dynamic visuals"""
        # Title
        title = Text("Number Sequence", font_size=42, color=GOLD)
        title.to_edge(UP, buff=0.8)
        self.play(FadeIn(title, shift=DOWN), run_time=0.6)
        
        # Fibonacci or generic sequence
        sequence = [1, 1, 2, 3, 5, 8, 13, 21]
        numbers = VGroup()
        
        # Create numbers in a grid
        for i, num in enumerate(sequence):
            number_mob = Text(
                str(num),
                font_size=52,
                color=YELLOW,
                weight=BOLD
            )
            
            # Position in flowing layout
            if i < 4:
                number_mob.move_to(LEFT * 3 + RIGHT * i * 1.8 + UP * 0.5)
            else:
                number_mob.move_to(LEFT * 3 + RIGHT * (i-4) * 1.8 + DOWN * 0.8)
            
            numbers.add(number_mob)
            
            # Animated entrance
            self.play(
                FadeIn(number_mob, scale=0.5),
                number_mob.animate.set_color(YELLOW),
                run_time=0.4
            )
        
        self.wait(0.8)
        
        # Show connections with arrows
        arrows = VGroup()
        for i in range(len(numbers) - 1):
            if i < 3 or i >= 4:
                arrow = Arrow(
                    numbers[i].get_right(),
                    numbers[i+1].get_left(),
                    buff=0.1,
                    stroke_width=3,
                    color=GREEN,
                    max_tip_length_to_length_ratio=0.15
                )
                arrows.add(arrow)
        
        self.play(LaggedStart(*[Create(a) for a in arrows], lag_ratio=0.15), run_time=1.2)
        
        # Highlight pattern with color wave
        for num in numbers:
            self.play(
                num.animate.set_color_by_gradient(GREEN, TEAL).scale(1.1),
                run_time=0.25
            )
            self.play(
                num.animate.set_color(YELLOW).scale(1/1.1),
                run_time=0.25
            )
        
        self.wait(1)
        
        # Exit
        self.play(
            FadeOut(VGroup(numbers, arrows, title), shift=DOWN),
            run_time=0.8
        )
    
    def animate_geometry(self):
        """Animate geometric shapes and properties"""
'''
    
    # Add geometry based on topic
    if "circle" in topic.lower():
        code += '''        circle = Circle(radius=2, color=BLUE, stroke_width=5)
        self.play(Create(circle), run_time=2)
        
        # Show radius
        radius = Line(ORIGIN, circle.point_at_angle(0), color=RED, stroke_width=4)
        r_label = MathTex("r", color=RED, font_size=44).next_to(radius, DOWN)
        
        self.play(Create(radius), Write(r_label), run_time=1)
        self.wait(1)
        
        # Show circumference formula
'''
        code += f'''        formula = MathTex(r"{formula}", font_size=48, color=YELLOW)
        formula.to_edge(DOWN, buff=1)
        self.play(Write(formula), run_time=1.5)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(circle, radius, r_label, formula)), run_time=0.5)
'''
    
    elif "triangle" in topic.lower():
        code += '''        # Create triangle
        triangle = Polygon(
            LEFT * 2 + DOWN * 1.5,
            LEFT * 2 + UP * 1.5,
            RIGHT * 1 + DOWN * 1.5,
            color=YELLOW,
            stroke_width=4
        )
        
        self.play(Create(triangle), run_time=1.5)
        
        # Label sides
        labels = VGroup(
            MathTex("a", font_size=40, color=RED).next_to(triangle, LEFT),
            MathTex("b", font_size=40, color=GREEN).next_to(triangle, UP),
            MathTex("c", font_size=40, color=BLUE).next_to(triangle, DOWN)
        )
        
        self.play(Write(labels), run_time=1)
        self.wait(1)
        
        # Show formula
'''
        code += f'''        formula = MathTex(r"{formula}", font_size=52, color=GOLD)
        formula.to_edge(DOWN, buff=1)
        self.play(Write(formula), run_time=1.5)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(triangle, labels, formula)), run_time=0.5)
'''
    
    else:
        # Generic shapes
        code += '''        shapes = VGroup(
            Circle(radius=0.8, color=BLUE, fill_opacity=0.3),
            Square(side_length=1.6, color=GREEN, fill_opacity=0.3),
            Triangle(color=RED, fill_opacity=0.3)
        ).arrange(RIGHT, buff=0.8)
        
        self.play(Create(shapes), run_time=2)
        self.wait(1)
        self.play(FadeOut(shapes), run_time=0.5)
'''
    
    code += '''
    def animate_theorem(self):
        """Animate theorem or mathematical proof"""
'''
    
    code += f'''        theorem_text = Text(
            "{topic}",
            font_size=44,
            color=GOLD,
            weight=BOLD
        )
        
        if theorem_text.width > config.frame_width - 1:
            theorem_text.scale_to_fit_width(config.frame_width - 1)
        
        theorem_text.to_edge(UP, buff=1)
        
        self.play(Write(theorem_text), run_time=1.5)
        self.wait(0.5)
        
        # Show the main formula
        formula = MathTex(
            r"{formula}",
            font_size=56,
            color=YELLOW
        )
        
        self.play(Write(formula), run_time=2)
        self.wait(1.5)
        
        # Highlight parts
        self.play(Indicate(formula, color=GREEN, scale_factor=1.2), run_time=1)
        self.wait(1)
        
        self.play(FadeOut(VGroup(theorem_text, formula)), run_time=0.5)
    
    def animate_formula(self):
        """Animate mathematical formulas with visual flair"""
        # Background glow effect
        glow_circle = Circle(radius=2, color=BLUE, fill_opacity=0.1, stroke_width=0)
        
        self.play(FadeIn(glow_circle), run_time=0.5)
        
        # Main formula
        formula = MathTex(
            r"{formula}",
            font_size=68,
            color=BLUE
        )
        
        # Build formula piece by piece
        self.play(Write(formula), run_time=2.5)
        self.wait(0.8)
        
        # Colorful transformation
        self.play(
            formula.animate.set_color_by_gradient(YELLOW, GOLD, RED).scale(1.15),
            glow_circle.animate.scale(1.2).set_color(YELLOW),
            run_time=1
        )
        
        self.wait(0.5)
        
        # Highlight each part
        self.play(
            Indicate(formula, color=GREEN, scale_factor=1.3),
            run_time=1.2
        )
        
        # Return to original
        self.play(
            formula.animate.set_color(BLUE).scale(1/1.15),
            glow_circle.animate.scale(1/1.2).set_color(BLUE),
            run_time=0.8
        )
        
        self.wait(1)
        
        # Exit with rotation
        self.play(
            FadeOut(VGroup(formula, glow_circle), scale=1.5, shift=UP),
            run_time=0.8
        )
    
    def animate_fractal(self):
        """Animate fractal patterns"""
        def koch_curve(order, length=3):
            if order == 0:
                return Line(ORIGIN, RIGHT * length)
            else:
                smaller = koch_curve(order - 1, length / 3)
                return VGroup(
                    smaller.copy(),
                    smaller.copy().rotate(PI/3).shift(RIGHT * length/3),
                    smaller.copy().rotate(-PI/3).shift(RIGHT * 2*length/3),
                    smaller.copy().shift(RIGHT * length)
                )
        
        fractal = VGroup()
        for i in range(4):
            curve = Line(ORIGIN, RIGHT * 2, color=BLUE, stroke_width=3)
            curve.rotate(i * PI/2).shift(ORIGIN)
            fractal.add(curve)
        
        self.play(Create(fractal), run_time=3)
        self.wait(1)
        self.play(FadeOut(fractal), run_time=0.5)
    
    def animate_calculus(self):
        """Animate calculus concepts"""
        axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[-2, 4, 1],
            x_length=6,
            y_length=4,
            tips=False
        )
        
        # Plot a function
        graph = axes.plot(lambda x: x**2, color=YELLOW, stroke_width=4)
        
        self.play(Create(axes), run_time=1)
        self.play(Create(graph), run_time=2)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(axes, graph)), run_time=0.5)
    
    def animate_graph_network(self):
        """Animate graph theory networks"""
        vertices = VGroup(*[
            Dot(point=np.array([np.cos(i*2*PI/5), np.sin(i*2*PI/5), 0]) * 2, color=BLUE, radius=0.15)
            for i in range(5)
        ])
        
        edges = VGroup()
        for i in range(5):
            for j in range(i+1, 5):
                edge = Line(
                    vertices[i].get_center(),
                    vertices[j].get_center(),
                    color=YELLOW,
                    stroke_width=2
                )
                edges.add(edge)
        
        self.play(Create(edges), run_time=2)
        self.play(FadeIn(vertices, lag_ratio=0.1), run_time=1)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(vertices, edges)), run_time=0.5)
    
    def animate_probability(self):
        """Animate probability concepts"""
        # Coin flip visualization
        coins = VGroup(*[
            Circle(radius=0.3, color=YELLOW, fill_opacity=0.5).shift(LEFT * 2 + RIGHT * i * 0.7)
            for i in range(6)
        ])
        
        self.play(FadeIn(coins, lag_ratio=0.1), run_time=1.5)
        self.wait(1)
        
        # Random colors
        for coin in coins:
            color = random.choice([RED, GREEN])
            self.play(coin.animate.set_fill(color, opacity=0.7), run_time=0.2)
        
        self.wait(1)
        self.play(FadeOut(coins), run_time=0.5)
    
    def show_key_points(self):
        """Show key points from the script with dynamic animations"""
'''
    
    # Add key points from script with enhanced visuals and proper timing
    if key_points:
        for i, point in enumerate(key_points[:5]):  # Show first 5 key points
            # Get text and ensure it's not too long
            raw_text = point['text']
            
            # Escape quotes and clean text
            clean_text = raw_text.replace('"', '\\"').replace("'", "\\'").replace('\n', ' ').replace('\r', '').replace('\\', '/')
            
            # Calculate display time based on text length
            display_time = max(2.5, min(4.5, len(clean_text) / 25))  # 25 chars per second reading speed
            
            # Alternate between different text styles for variety
            if i % 3 == 0:
                # Full screen text with background - use Paragraph for wrapping
                code += f'''
        # Point {i+1}: Full screen emphasis (Duration: {display_time:.1f}s)
        bg_box_{i+1} = Rectangle(
            width=config.frame_width - 1.0,
            height=4.0,
            fill_color=BLUE_D,
            fill_opacity=0.85,
            stroke_color=YELLOW,
            stroke_width=4
        )
        
        point_text_{i+1} = Paragraph(
            "{clean_text}",
            font_size=32,
            color=WHITE,
            line_spacing=1.5,
            alignment="center",
            width=config.frame_width - 2.0
        ).move_to(ORIGIN)
        
        self.play(FadeIn(bg_box_{i+1}, scale=0.95), run_time=0.5)
        self.play(Write(point_text_{i+1}, run_time=1.2))
        self.wait({display_time})
        self.play(FadeOut(VGroup(bg_box_{i+1}, point_text_{i+1}), shift=UP), run_time=0.5)
'''
            elif i % 3 == 1:
                # Bullet point style with icon - use Paragraph for wrapping
                code += f'''
        # Point {i+1}: Bullet point with icon (Duration: {display_time:.1f}s)
        bullet_{i+1} = Dot(color=YELLOW, radius=0.15).to_edge(LEFT, buff=0.8).shift(UP * 1.0)
        
        point_text_{i+1} = Paragraph(
            "{clean_text}",
            font_size=30,
            color=WHITE,
            line_spacing=1.4,
            alignment="left",
            width=config.frame_width - 2.5
        )
        point_text_{i+1}.next_to(bullet_{i+1}, RIGHT, buff=0.4).align_to(bullet_{i+1}, UP)
        
        self.play(FadeIn(bullet_{i+1}, scale=2), run_time=0.3)
        self.play(Write(point_text_{i+1}, run_time=1.2))
        self.wait({display_time})
        self.play(FadeOut(VGroup(bullet_{i+1}, point_text_{i+1}), shift=LEFT), run_time=0.5)
'''
            else:
                # Animated text with underline - use Paragraph for wrapping
                code += f'''
        # Point {i+1}: Text with animated underline (Duration: {display_time:.1f}s)
        point_text_{i+1} = Paragraph(
            "{clean_text}",
            font_size=30,
            color=WHITE,
            line_spacing=1.4,
            alignment="center",
            width=config.frame_width - 2.0
        ).move_to(ORIGIN)
        
        underline_{i+1} = Line(
            point_text_{i+1}.get_left() + DOWN * 0.3,
            point_text_{i+1}.get_right() + DOWN * 0.3,
            color=GOLD,
            stroke_width=4
        )
        
        self.play(FadeIn(point_text_{i+1}, shift=DOWN), run_time=0.7)
        self.play(Create(underline_{i+1}), run_time=0.7)
        self.wait({display_time})
        self.play(FadeOut(VGroup(point_text_{i+1}, underline_{i+1}), shift=UP), run_time=0.5)
'''
    else:
        # Fallback if no key points
        code += '''
        fallback_text = Text(
            "Fascinating Mathematics!",
            font_size=48,
            color=YELLOW,
            weight=BOLD
        )
        
        # Ensure text fits
        max_width = config.frame_width - 1.0
        if fallback_text.width > max_width:
            fallback_text.scale(max_width / fallback_text.width)
        
        self.play(Write(fallback_text, run_time=1.5))
        self.wait(2)
        self.play(FadeOut(fallback_text), run_time=0.5)
'''
    
    code += '''
    def show_outro(self):
        """Show outro with engaging call to action"""
        # Thank you message
        thanks = Text(
            "Thanks for Watching!",
            font_size=48,
            color=WHITE,
            weight=BOLD
        )
        
        self.play(Write(thanks, run_time=1.2))
        self.wait(0.8)
        self.play(FadeOut(thanks, shift=UP), run_time=0.5)
        
        # Animated CTA box with particles
        cta_box = Rectangle(
            width=config.frame_width - 1,
            height=2.8,
            fill_color=BLUE_D,
            fill_opacity=0.9,
            stroke_color=GOLD,
            stroke_width=8
        ).set_z_index(1)
        
        # Like icon (heart)
        heart = Text("❤️", font_size=60)
        heart.to_edge(LEFT, buff=1).shift(UP * 0.3)
        
        # Subscribe text
        cta_text = Text(
            "LIKE & SUBSCRIBE!",
            font_size=48,
            weight=BOLD,
            color=WHITE,
            gradient=(WHITE, YELLOW)
        )
        cta_text.next_to(heart, RIGHT, buff=0.4)
        
        # Bell icon
        bell = Text("🔔", font_size=50)
        bell.to_edge(RIGHT, buff=1).shift(UP * 0.3)
        
        cta_group = VGroup(cta_box, heart, cta_text, bell)
        
        # Animated entrance
        self.play(FadeIn(cta_box, scale=0.9), run_time=0.6)
        self.play(
            FadeIn(heart, shift=RIGHT, scale=1.5),
            Write(cta_text, run_time=1),
            FadeIn(bell, shift=LEFT, scale=1.5),
            run_time=1.2
        )
        
        # Pulse animation
        self.play(
            cta_group.animate.scale(1.08),
            run_time=0.4
        )
        self.play(
            cta_group.animate.scale(1/1.08),
            run_time=0.4
        )
        
        # Wiggle effect on icons
        self.play(
            heart.animate.rotate(0.2),
            bell.animate.rotate(-0.2),
            run_time=0.3
        )
        self.play(
            heart.animate.rotate(-0.2),
            bell.animate.rotate(0.2),
            run_time=0.3
        )
        
        self.wait(1.5)


# Configure for vertical video (YouTube Shorts)
if __name__ == "__main__":
    from manim import config
    config.pixel_height = 1920
    config.pixel_width = 1080
    config.frame_height = 16.0
    config.frame_width = 9.0
'''
    
    return code


def save_manim_script(code, output_path="scripts/render_manim_dynamic.py"):
    """Save the generated Manim code to file"""
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(code)
    
    print(f"✅ Manim script saved: {output_file}")
    return output_file


if __name__ == "__main__":
    # Test the generator
    topic_file = Path("output/topic.json")
    script_file = Path("output/script.json")
    
    if topic_file.exists() and script_file.exists():
        with open(topic_file) as f:
            topic_data = json.load(f)
        
        with open(script_file) as f:
            script_data = json.load(f)
        
        topic = topic_data.get("topic", "Mathematics")
        script = script_data.get("script", "")
        
        code = generate_manim_code(topic, script, {}, "x^2 + y^2 = z^2")
        save_manim_script(code)
        
        print("✅ Test generation complete!")
