"""
Dynamically generates Manim animation code based on topic and script
This ensures every video is unique, interactive, and educational
"""

import json
from pathlib import Path
import re


def analyze_topic_type(topic, wiki_info, script):
    """Analyze topic to determine what kind of animations to create"""
    
    topic_lower = topic.lower()
    script_lower = script.lower()
    wiki_text = wiki_info.get("summary", "").lower() if wiki_info else ""
    
    # Detect topic categories
    animations = []
    
    # Number sequences
    if any(word in topic_lower for word in ["fibonacci", "prime", "sequence", "series"]):
        animations.append("number_sequence")
    
    # Geometry
    if any(word in topic_lower for word in ["triangle", "circle", "square", "polygon", "geometry"]):
        animations.append("geometric_shapes")
    
    # Theorems with proofs
    if any(word in topic_lower for word in ["theorem", "pythagorean", "fermat", "euler"]):
        animations.append("theorem_proof")
    
    # Equations and formulas
    if any(word in script_lower for word in ["equation", "formula", "equals", "="]):
        animations.append("formula_visualization")
    
    # Patterns and fractals
    if any(word in topic_lower for word in ["fractal", "mandelbrot", "pattern", "chaos"]):
        animations.append("fractal_pattern")
    
    # Calculus
    if any(word in topic_lower for word in ["derivative", "integral", "limit", "calculus"]):
        animations.append("calculus_graph")
    
    # Graph theory
    if any(word in topic_lower for word in ["graph", "network", "tree", "vertex"]):
        animations.append("graph_network")
    
    # Probability
    if any(word in topic_lower for word in ["probability", "random", "distribution", "statistics"]):
        animations.append("probability_visual")
    
    # Default: show concept with text and shapes
    if not animations:
        animations.append("concept_explanation")
    
    return animations


def extract_key_points(script):
    """Extract key points from script for visualization"""
    sentences = script.split('. ')
    
    key_points = []
    for i, sentence in enumerate(sentences[:8]):  # Max 8 points
        if sentence.strip():
            # Clean the sentence
            clean = sentence.strip()
            if not clean.endswith('.'):
                clean += '.'
            
            key_points.append({
                "text": clean,
                "index": i,
                "has_number": bool(re.search(r'\d+', clean)),
                "has_formula": bool(re.search(r'[=+\-*/^]', clean))
            })
    
    return key_points


def generate_manim_code(topic, script, wiki_info, formula):
    """Generate complete Manim animation code dynamically"""
    
    print(f"🎨 Generating custom Manim code for: {topic}")
    
    # Analyze what animations to include
    animation_types = analyze_topic_type(topic, wiki_info, script)
    key_points = extract_key_points(script)
    
    print(f"  Animation types: {', '.join(animation_types)}")
    print(f"  Key points: {len(key_points)}")
    
    # Escape special characters in topic for Python strings
    safe_topic = topic.encode('ascii', 'ignore').decode('ascii')  # Remove non-ASCII
    if not safe_topic:
        safe_topic = topic  # Keep original if all chars were non-ASCII
    
    # Build the Manim script
    code = f'''"""
Dynamically Generated Manim Animation
Topic: {safe_topic}
Generated by AI-powered video creation system
"""

from manim import *
import numpy as np

class DynamicScene(Scene):
    """Custom animation for: {safe_topic}"""
    
    def construct(self):
        # Add audio
        audio_file = "output/audio.mp3"
        from pathlib import Path
        if Path(audio_file).exists():
            self.add_sound(audio_file)
        
        # === INTRO (0-4 seconds) ===
        self.show_intro()
        
        # === MAIN CONTENT (4-50 seconds) ===
'''
    
    # Add appropriate animations based on analysis
    if "number_sequence" in animation_types:
        code += "        self.animate_number_sequence()\n"
    
    if "geometric_shapes" in animation_types:
        code += "        self.animate_geometry()\n"
    
    if "theorem_proof" in animation_types:
        code += "        self.animate_theorem()\n"
    
    if "formula_visualization" in animation_types:
        code += "        self.animate_formula()\n"
    
    if "fractal_pattern" in animation_types:
        code += "        self.animate_fractal()\n"
    
    if "calculus_graph" in animation_types:
        code += "        self.animate_calculus()\n"
    
    if "graph_network" in animation_types:
        code += "        self.animate_graph_network()\n"
    
    if "probability_visual" in animation_types:
        code += "        self.animate_probability()\n"
    
    # Always show key points
    code += "        self.show_key_points()\n"
    
    code += '''
        # === OUTRO (50-60 seconds) ===
        self.show_outro()
    
    def show_intro(self):
        """Show title and topic introduction"""
        title = Text(
            "''' + safe_topic.replace('"', '\\"') + '''",
            font_size=56,
            weight=BOLD,
            color=YELLOW
        )
        
        if title.width > config.frame_width - 1.5:
            title.scale_to_fit_width(config.frame_width - 1.5)
    code += "        self.show_key_points()\n"
    
    # Outro
    code += '''        
        # === OUTRO (50-60 seconds) ===
        self.show_outro()
    
    def show_intro(self):
        """Show title and topic introduction"""
'''
    
    code += f'''        title = Text(
            "{topic}",
            font_size=56,
            weight=BOLD,
            color=YELLOW
        )
        
        if title.width > config.frame_width - 1.5:
            title.scale_to_fit_width(config.frame_width - 1.5)
        
        subtitle = Text("Mathematics", font_size=40, color=BLUE_B)
        subtitle.next_to(title, DOWN, buff=0.5)
        
        self.play(Write(title, run_time=1.5))
        self.play(FadeIn(subtitle, shift=UP, run_time=1))
        self.wait(1)
        
        self.play(
            FadeOut(title, shift=UP),
            FadeOut(subtitle, shift=UP),
            run_time=0.5
        )
    
    def animate_number_sequence(self):
        """Animate number sequences"""
        numbers = VGroup()
        sequence = [1, 1, 2, 3, 5, 8, 13, 21]  # Example sequence
        
        for i, num in enumerate(sequence):
            number_mob = Text(str(num), font_size=48, color=YELLOW)
            if i == 0:
                number_mob.shift(LEFT * 3 + UP * 1)
            else:
                number_mob.next_to(numbers[-1], RIGHT, buff=0.4)
            
            numbers.add(number_mob)
            self.play(FadeIn(number_mob, scale=0.7), run_time=0.4)
        
        self.wait(1)
        
        # Show pattern
        for num in numbers:
            self.play(num.animate.set_color(GREEN), run_time=0.2)
        
        self.wait(1)
        self.play(FadeOut(numbers), run_time=0.5)
    
    def animate_geometry(self):
        """Animate geometric shapes and properties"""
'''
    
    # Add geometry based on topic
    if "circle" in topic.lower():
        code += '''        circle = Circle(radius=2, color=BLUE, stroke_width=5)
        self.play(Create(circle), run_time=2)
        
        # Show radius
        radius = Line(ORIGIN, circle.point_at_angle(0), color=RED, stroke_width=4)
        r_label = MathTex("r", color=RED, font_size=44).next_to(radius, DOWN)
        
        self.play(Create(radius), Write(r_label), run_time=1)
        self.wait(1)
        
        # Show circumference formula
'''
        code += f'''        formula = MathTex(r"{formula}", font_size=48, color=YELLOW)
        formula.to_edge(DOWN, buff=1)
        self.play(Write(formula), run_time=1.5)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(circle, radius, r_label, formula)), run_time=0.5)
'''
    
    elif "triangle" in topic.lower():
        code += '''        # Create triangle
        triangle = Polygon(
            LEFT * 2 + DOWN * 1.5,
            LEFT * 2 + UP * 1.5,
            RIGHT * 1 + DOWN * 1.5,
            color=YELLOW,
            stroke_width=4
        )
        
        self.play(Create(triangle), run_time=1.5)
        
        # Label sides
        labels = VGroup(
            MathTex("a", font_size=40, color=RED).next_to(triangle, LEFT),
            MathTex("b", font_size=40, color=GREEN).next_to(triangle, UP),
            MathTex("c", font_size=40, color=BLUE).next_to(triangle, DOWN)
        )
        
        self.play(Write(labels), run_time=1)
        self.wait(1)
        
        # Show formula
'''
        code += f'''        formula = MathTex(r"{formula}", font_size=52, color=GOLD)
        formula.to_edge(DOWN, buff=1)
        self.play(Write(formula), run_time=1.5)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(triangle, labels, formula)), run_time=0.5)
'''
    
    else:
        # Generic shapes
        code += '''        shapes = VGroup(
            Circle(radius=0.8, color=BLUE, fill_opacity=0.3),
            Square(side_length=1.6, color=GREEN, fill_opacity=0.3),
            Triangle(color=RED, fill_opacity=0.3)
        ).arrange(RIGHT, buff=0.8)
        
        self.play(Create(shapes), run_time=2)
        self.wait(1)
        self.play(FadeOut(shapes), run_time=0.5)
'''
    
    code += '''
    def animate_theorem(self):
        """Animate theorem or mathematical proof"""
'''
    
    code += f'''        theorem_text = Text(
            "{topic}",
            font_size=44,
            color=GOLD,
            weight=BOLD
        )
        
        if theorem_text.width > config.frame_width - 1:
            theorem_text.scale_to_fit_width(config.frame_width - 1)
        
        theorem_text.to_edge(UP, buff=1)
        
        self.play(Write(theorem_text), run_time=1.5)
        self.wait(0.5)
        
        # Show the main formula
        formula = MathTex(
            r"{formula}",
            font_size=56,
            color=YELLOW
        )
        
        self.play(Write(formula), run_time=2)
        self.wait(1.5)
        
        # Highlight parts
        self.play(Indicate(formula, color=GREEN, scale_factor=1.2), run_time=1)
        self.wait(1)
        
        self.play(FadeOut(VGroup(theorem_text, formula)), run_time=0.5)
    
    def animate_formula(self):
        """Animate mathematical formulas"""
        formula = MathTex(
            r"{formula}",
            font_size=64,
            color=BLUE
        )
        
        self.play(Write(formula), run_time=2)
        self.wait(1)
        
        # Transform or highlight
        self.play(
            formula.animate.set_color(YELLOW).scale(1.1),
            run_time=0.8
        )
        self.play(
            formula.animate.set_color(BLUE).scale(1/1.1),
            run_time=0.8
        )
        
        self.wait(1)
        self.play(FadeOut(formula), run_time=0.5)
    
    def animate_fractal(self):
        """Animate fractal patterns"""
        def koch_curve(order, length=3):
            if order == 0:
                return Line(ORIGIN, RIGHT * length)
            else:
                smaller = koch_curve(order - 1, length / 3)
                return VGroup(
                    smaller.copy(),
                    smaller.copy().rotate(PI/3).shift(RIGHT * length/3),
                    smaller.copy().rotate(-PI/3).shift(RIGHT * 2*length/3),
                    smaller.copy().shift(RIGHT * length)
                )
        
        fractal = VGroup()
        for i in range(4):
            curve = Line(ORIGIN, RIGHT * 2, color=BLUE, stroke_width=3)
            curve.rotate(i * PI/2).shift(ORIGIN)
            fractal.add(curve)
        
        self.play(Create(fractal), run_time=3)
        self.wait(1)
        self.play(FadeOut(fractal), run_time=0.5)
    
    def animate_calculus(self):
        """Animate calculus concepts"""
        axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[-2, 4, 1],
            x_length=6,
            y_length=4,
            tips=False
        )
        
        # Plot a function
        graph = axes.plot(lambda x: x**2, color=YELLOW, stroke_width=4)
        
        self.play(Create(axes), run_time=1)
        self.play(Create(graph), run_time=2)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(axes, graph)), run_time=0.5)
    
    def animate_graph_network(self):
        """Animate graph theory networks"""
        vertices = VGroup(*[
            Dot(point=np.array([np.cos(i*2*PI/5), np.sin(i*2*PI/5), 0]) * 2, color=BLUE, radius=0.15)
            for i in range(5)
        ])
        
        edges = VGroup()
        for i in range(5):
            for j in range(i+1, 5):
                edge = Line(
                    vertices[i].get_center(),
                    vertices[j].get_center(),
                    color=YELLOW,
                    stroke_width=2
                )
                edges.add(edge)
        
        self.play(Create(edges), run_time=2)
        self.play(FadeIn(vertices, lag_ratio=0.1), run_time=1)
        self.wait(1.5)
        
        self.play(FadeOut(VGroup(vertices, edges)), run_time=0.5)
    
    def animate_probability(self):
        """Animate probability concepts"""
        # Coin flip visualization
        coins = VGroup(*[
            Circle(radius=0.3, color=YELLOW, fill_opacity=0.5).shift(LEFT * 2 + RIGHT * i * 0.7)
            for i in range(6)
        ])
        
        self.play(FadeIn(coins, lag_ratio=0.1), run_time=1.5)
        self.wait(1)
        
        # Random colors
        for coin in coins:
            color = random.choice([RED, GREEN])
            self.play(coin.animate.set_fill(color, opacity=0.7), run_time=0.2)
        
        self.wait(1)
        self.play(FadeOut(coins), run_time=0.5)
    
    def show_key_points(self):
        """Show key points from the script"""
'''
    
    # Add key points from script
    for i, point in enumerate(key_points[:4]):  # Show first 4 key points
        # Escape quotes and limit length
        clean_text = point['text'][:80].replace('"', '\\"').replace("'", "\\'")
        
        code += f'''        
        point_{i+1} = Text(
            "{clean_text}",
            font_size=36,
            color=WHITE,
            line_spacing=1.2
        )
        
        if point_{i+1}.width > config.frame_width - 1:
            point_{i+1}.scale_to_fit_width(config.frame_width - 1)
        
        self.play(Write(point_{i+1}, run_time=2))
        self.wait(2)
        self.play(FadeOut(point_{i+1}, run_time=0.5))
'''
    
    code += '''
    def show_outro(self):
        """Show outro with call to action"""
        cta_box = Rectangle(
            width=config.frame_width - 1,
            height=2.5,
            fill_color=BLUE_D,
            fill_opacity=0.8,
            stroke_color=GOLD,
            stroke_width=6
        )
        
        cta_text = Text(
            "❤️ LIKE & SUBSCRIBE!",
            font_size=52,
            weight=BOLD,
            color=WHITE
        )
        
        cta = VGroup(cta_box, cta_text)
        
        self.play(FadeIn(cta, scale=0.8), run_time=1)
        self.play(cta.animate.scale(1.1), run_time=0.5)
        self.play(cta.animate.scale(1/1.1), run_time=0.5)
        self.wait(2)


# Configure for vertical video (YouTube Shorts)
if __name__ == "__main__":
    from manim import config
    config.pixel_height = 1920
    config.pixel_width = 1080
    config.frame_height = 16.0
    config.frame_width = 9.0
'''
    
    return code


def save_manim_script(code, output_path="scripts/render_manim_dynamic.py"):
    """Save the generated Manim code to file"""
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(code)
    
    print(f"✅ Manim script saved: {output_file}")
    return output_file


if __name__ == "__main__":
    # Test the generator
    topic_file = Path("output/topic.json")
    script_file = Path("output/script.json")
    
    if topic_file.exists() and script_file.exists():
        with open(topic_file) as f:
            topic_data = json.load(f)
        
        with open(script_file) as f:
            script_data = json.load(f)
        
        topic = topic_data.get("topic", "Mathematics")
        script = script_data.get("script", "")
        
        code = generate_manim_code(topic, script, {}, "x^2 + y^2 = z^2")
        save_manim_script(code)
        
        print("✅ Test generation complete!")
